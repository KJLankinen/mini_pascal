fn allocate(i32 n_bytes) -> i32 "addr"
    - allocates "n_bytes" bytes
    - returns the location where the allocation was done

fn check_bounds(i32 arr, i32 idx) -> i32 "idx"
    - checks that the length of array at "arr" >= idx
    - returns idx if yes, otherwise unreachable

fn new_array() -> i32 "addr"
    - allocates space for three i32 values: pdata, length, capacity
    - allocates 1024 bytes of memory at "pdata" (use "allocate")
    - returns a pointer to the first of the three consecutive i32 values

fn copy_array(i32 dst, i32 src) -> i32 "dst"
    - copies values of length and capacity from src to dst
    - copies bytes from src pdata to dst pdata
    - returns the value dst

fn get_string_literal(i32 idx) -> i32 "addr"
    - gets the index of a stored string literal
    - calculates/fetches the address from that index
    - returns the address of the string literal

fn read_input() -> void
    - reads the contents of stdin to the stdin array (pretty much fd_read)

fn bool_from_input() -> i32
    - converts the next whitespaced delimited value from stdin buffer to a bool(i32, [0, 1]) value (atob)
    - returns the converted value

fn i32_from_input() -> i32
    - converts the next whitespaced delimited value from stdin buffer to a i32 value (atoi)
    - returns the converted value

fn f32_from_input() -> f32
    - converts the next whitespaced delimited value from stdin buffer to a f32 value (atof)
    - returns the converted value

fn string_from_input() -> i32 "addr"
    - creates a new string (call new_array)
    - adds the next whitespace delimited value from stdin buffer to that string
    - returns the address of the string

fn write_bool(i32 value) -> void
    - takes in a boolean value and converts it to "true"/"false" string and prints it to stdout (btoa)

fn write_i32(i32 value) -> void
    - takes in a i32 value and converts it to a byte string (itoa) and prints it to stdout

fn write_f32(f32 value) -> void
    - takes in a f32 value and converts it to a byte string (ftoa) and prints it to stdout

fn write_string(i32 addr) -> 
    - writes the contents of the string at "addr" to stdout

fn string_eq(i32 addr1, i32 addr2) -> i32 "t/f"
    - takes the addresses of two strings and compares their lengths
    - returns 1 if equal 0 if not

fn string_neq(i32 addr1, i32 addr2) -> i32 "t/f"
    - takes the addresses of two strings and compares their lengths
    - returns 0 if equal, 1 if not

fn string_great(i32 addr1, i32 addr2) -> i32 "t/f"
    - takes the addresses of two strings and compares their lengths
    - returns 1 if str1.len > str2.len, 0 otherwise

fn string_great_eq(i32 addr1, i32 addr2) -> i32 "t/f"
    - takes the addresses of two strings and compares their lengths
    - returns 1 if str1.len >= str2.len, 0 otherwise

fn string_less(i32 addr1, i32 addr2) -> i32 "t/f"
    - takes the addresses of two strings and compares their lengths
    - returns 1 if str1.len < str2.len, 0 otherwise

fn string_less_eq(i32 addr1, i32 addr2) -> i32 "t/f"
    - takes the addresses of two strings and compares their lengths
    - returns 1 if str1.len <= str2.len, 0 otherwise

fn string_concatenate(i32 addr1, i32 addr2) -> i32 "addr"
    - takes as input two strings
    - adds the contents of the second to the first at "addr1 + str1.len", while within capacity
    - returns "addr1"

fn array_size(i32 addr) -> i32 "length"
    - checks the length of the array at addr
    - returns it (divided by four, lenght is bytes)

fn array_access_i(i32 addr, i32 idx) -> i32
    - call "check_bounds"
    - loads value at addr + idx to stack and returns it

fn array_access_f(i32 addr, i32 idx) -> f32
    - call "check_bounds"
    - loads value at addr + idx to stack and returns it

fn array_assign_i(i32 addr, i32 idx, i32 value) -> void
    - call "check_bounds"
    - store value to addr + idx

fn array_assign_f(i32 addr, i32 idx, f32 value) -> void
    - call "check_bounds"
    - store value to addr + idx
